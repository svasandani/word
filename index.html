<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="theme-color" content="#a5c9ff" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;700;900&display=swap"
      rel="stylesheet"
    />

    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <title>Play Word</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        font-family: "Be Vietnam Pro", sans-serif;
        -webkit-tap-highlight-color: transparent;
      }

      :root {
        --black: #000000;
        --black-on-blue: #000000;
        --white: #ffffff;
        --light-gray: #e5e5e5;
        --lightest-gray: #f1f1f1;
        --gray: #a3a3a3;
        --green: #3eb23e;
        --light-green: #a3fab3;
        --yellow: #d3b342;
        --blue: #a5c9ff;
        --blue-accent: #668bc3;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --black: #e2e2e2;
          --white: #1c1c1c;
          --light-gray: #4c4c4c;
          --lightest-gray: #2f2f2f;
          --light-green: #3e5c3f;
        }
      }

      body {
        touch-action: none;

        display: grid;
        place-content: center;

        margin: 0;
        padding: 0;

        font-size: 1rem;

        background-color: var(--white);
        color: var(--black);
        stroke: var(--black);
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 0;
      }
      h1 {
        font-size: 1.375rem;
        font-weight: 900;
        line-height: 2rem;
      }
      nav h1 {
        color: var(--black-on-blue);
      }

      .dialog {
        appearance: none;
        border: none;
        outline: none;

        margin: 0;
        padding: 0;

        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;

        font-size: 0.75rem;

        background-color: var(--white);
        color: var(--black);
        stroke: var(--black);
      }
      .dialog[open] {
        display: flex;
        flex-flow: column nowrap;
      }

      .one-pane {
        height: 100%;
        overflow-y: auto;

        display: grid;
        grid-template-columns: 1fr;
        justify-content: flex-start;
        gap: 1rem;
        padding: 1rem;
      }
      .one-pane-two-pane {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }
      .one-pane-two-pane.centered {
        align-items: center;
      }

      .two-pane {
        height: 100%;
        overflow-y: auto;

        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        padding: 1rem;
      }

      .pane {
        display: flex;
        flex-flow: column nowrap;
        gap: 1rem;
      }
      .pane .card {
        border-radius: 0.5rem;
        padding: 0.5rem;
        white-space: nowrap;
      }
      .pane .button {
        width: 100%;
      }

      .info.card {
        display: grid;
        grid-template-columns: auto 1fr;
        align-items: stretch;
        gap: 0.45rem 1rem;
        text-wrap: wrap;
      }
      .info > *:nth-child(2n) {
        text-align: right;
      }
      .info > *:nth-child(2n + 1) {
        text-align: left;
      }

      .divider {
        display: block;
        grid-column: 1 / -1;

        height: 1px;
        background-color: currentColor;
        margin-block: 2px;
      }
      details:not(.analysis-choice) > .divider {
        margin-block: calc(2px + 0.45rem);
      }
      details:not(.analysis-choice)[open] > summary {
        margin-bottom: 0.45rem;
      }

      details summary {
        cursor: pointer;
        list-style-type: none;
      }

      .analysis-choice.card {
        border-radius: 1rem;
      }
      .analysis-choice[open] > summary {
        margin-bottom: 1rem;
      }

      .wordlist {
        max-width: 100%;
        text-wrap: wrap;
      }

      .words {
        display: inline-flex;
        flex-flow: row nowrap;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        width: 100%;
      }
      .dotlist {
        display: flex;
        flex-flow: row wrap;
        align-items: center;
        gap: 0.2rem;
        padding-inline: 0.2rem;
      }
      .dot {
        display: flex;
        place-content: center;

        width: 1rem;
        height: 1rem;
        border-radius: 1rem;

        font-weight: 500;
        text-transform: capitalize;
      }
      .right {
        float: right;
      }

      .button {
        appearance: none;
        border: none;
        outline: none;

        border-radius: 0.5rem;
        color: var(--black);
        cursor: pointer;
        font-size: 1rem;
        padding: 0.375rem 0.5rem;

        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        justify-content: space-between;
      }
      .button:disabled {
        cursor: not-allowed;
        opacity: 0.4;
      }
      .button.small {
        font-size: 0.75rem;
      }
      .button svg {
        display: block;
      }
      .button span {
        padding: 0;
      }

      .checkbox {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.25rem;
      }

      .strong {
        font-weight: bold;
      }
      .light-gray {
        background-color: var(--light-gray);
      }
      .lightest-gray {
        background-color: var(--lightest-gray);
      }
      .gray {
        background-color: var(--gray);
        color: var(--black-on-blue);
        stroke: var(--black-on-blue);
      }
      .white {
        background-color: var(--white);
      }
      .green {
        background-color: var(--green);
        color: var(--black-on-blue);
        stroke: var(--black-on-blue);
      }
      .light-green {
        background-color: var(--light-green);
      }
      .blue {
        background-color: var(--blue);
        color: var(--black-on-blue);
        stroke: var(--black-on-blue);
      }
      .accent {
        background-color: var(--blue-accent);
        color: var(--black-on-blue);
        stroke: var(--black-on-blue);
      }
      .yellow {
        background-color: var(--yellow);
        color: var(--black-on-blue);
        stroke: var(--black-on-blue);
      }
      .yellow-color {
        color: var(--yellow);
      }

      .sticky {
        position: sticky;
        top: 0;
      }
      .hidden {
        display: none;
      }

      .nav {
        width: 100%;
        padding: 1rem;

        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        justify-content: space-between;
      }
      .nav-buttons {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.5rem;

        flex: 1 1 0;
      }
      .nav-buttons.left {
        justify-content: start;
      }
      .nav-buttons.right {
        justify-content: end;
      }

      .icon-group {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.375rem;
      }

      main#container {
        width: 100vw;
        height: 100vh;

        display: flex;
        flex-flow: column nowrap;
      }

      nav.nav {
        background-color: var(--blue);
      }

      section#game {
        width: 100%;
        height: 100%;
        flex-grow: 1;

        display: grid;
        grid-template-rows: auto 1fr;
      }

      div#input {
        padding: 2rem;

        display: flex;
        flex-flow: column nowrap;
        justify-content: flex-start;
        align-items: flex-start;
        gap: 0.5rem;

        overflow: scroll;
        position: relative;
        scroll-behavior: smooth;
      }

      .attempt-row {
        height: min-content;

        display: flex;
        justify-content: center;
        gap: 0.5rem;
        margin: 0 auto;

        text-transform: uppercase;
      }

      .attempt-letter {
        width: 3rem;
        height: 3rem;

        display: grid;
        place-content: center;

        border: 1px solid var(--light-gray);
        font-size: 1.5rem;
        font-weight: bold;
      }
      .attempt-letter.pulse {
        animation: pulse 200ms ease-out 1 forwards;
      }

      #archive-dialog {
        appearance: none;
        border: none;
        outline: none;
        margin: 0;

        position: absolute;
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);

        background-color: var(--blue);

        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
      }
      #archive-dialog[open] {
        animation: fade-in 300ms ease-out 1 forwards;
      }
      #archive-word {
        text-transform: uppercase;
      }

      div#buttons {
        height: min-content;
        width: 100%;
        max-width: 30rem;
        justify-self: center;
        padding-bottom: 2rem;
        overflow: scroll;

        display: grid;
        grid-template-rows: auto repeat(3, 1fr);
        gap: 0.375rem;
      }

      .button-row {
        display: flex;
        flex-flow: row nowrap;
        justify-content: stretch;
        gap: 0.375rem;

        padding-inline: 1rem;
      }
      div#buttons:has(#keyboard-input:focus) .button-row {
        display: none;
      }

      button.letter {
        appearance: none;
        border: none;
        outline: none;

        height: 4rem;
        padding: 0.25rem 0.5rem;
        flex: 1;

        display: grid;
        place-content: center;

        border-radius: 0.25rem;
        color: var(--black);
        cursor: pointer;
        font-size: 1.125rem;
        font-weight: 500;
      }
      button.letter:disabled {
        opacity: 0.4;
        transition: 300ms ease-in;
      }
      button.letter-input {
        text-transform: uppercase;
      }
      :where(button.letter) {
        background-color: var(--light-gray);
      }
      :where(button.letter:active) {
        opacity: 0.75;
      }

      button#letter-Enter {
        font-size: 0.85rem;
      }

      #keyboard-input {
        appearance: none;
        border: none;
        outline: none;
        caret-color: transparent;

        padding: 0;
        margin-inline: 1rem;
        width: calc(100% - 2rem);
        height: 2rem;

        text-align: center;

        background-color: var(--light-gray);
        border-radius: 0.25rem;
        color: var(--black);
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
      }
      #keyboard-input:disabled {
        opacity: 0.4;
        transition: 300ms ease-in;
      }

      #overview-daily-games,
      #overview-random-games-container,
      #overview-random-games {
        display: flex;
        flex-flow: column nowrap;
        gap: 0.5rem;
      }

      @keyframes fade-in {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(-1rem);
        }
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }

        50% {
          transform: scale(1.2);
        }

        100% {
          transform: scale(1);
        }
      }
    </style>
  </head>
  <body>
    <main id="container">
      <nav class="nav">
        <div class="nav-buttons left">
          <button id="overview-button" class="accent button">
            <svg
              width="20"
              height="20"
              viewBox="0 0 20 20"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M1.875 10L9.33667 2.5375C9.70333 2.17166 10.2967 2.17166 10.6625 2.5375L18.125 10M3.75 8.125V16.5625C3.75 17.08 4.17 17.5 4.6875 17.5H8.125V13.4375C8.125 12.92 8.545 12.5 9.0625 12.5H10.9375C11.455 12.5 11.875 12.92 11.875 13.4375V17.5H15.3125C15.83 17.5 16.25 17.08 16.25 16.5625V8.125M6.875 17.5H13.75"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <h1>WORD</h1>
        <div class="nav-buttons right">
          <button id="more-button" class="accent button">
            <svg
              width="20"
              height="20"
              viewBox="0 0 15 15"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M2.34375 1.875V8.90625C2.34375 9.27921 2.49191 9.6369 2.75563 9.90062C3.01935 10.1643 3.37704 10.3125 3.75 10.3125H5.15625M2.34375 1.875H1.40625M2.34375 1.875H12.6562M5.15625 10.3125H9.84375M5.15625 10.3125L4.53125 12.1875M12.6562 1.875H13.5938M12.6562 1.875V8.90625C12.6562 9.27921 12.5081 9.6369 12.2444 9.90062C11.9806 10.1643 11.623 10.3125 11.25 10.3125H9.84375M9.84375 10.3125L10.4688 12.1875M4.53125 12.1875H10.4688M4.53125 12.1875L4.21875 13.125M10.4688 12.1875L10.7812 13.125M4.6875 7.5L6.5625 5.625L7.905 6.9675C8.53575 6.06206 9.3576 5.30614 10.3125 4.75313"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
      </nav>
      <section id="game">
        <div id="input">
          <div id="attempt-1" class="attempt-row">
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
          </div>
          <div id="attempt-2" class="attempt-row">
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
          </div>
          <div id="attempt-3" class="attempt-row">
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
          </div>
          <div id="attempt-4" class="attempt-row">
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
          </div>
          <div id="attempt-5" class="attempt-row">
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
          </div>
          <div id="attempt-6" class="attempt-row">
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
            <div class="attempt-letter"></div>
          </div>
          <dialog id="archive-dialog">
            <span><strong id="archive-word"></strong></span>
          </dialog>
        </div>
        <div id="buttons">
          <input
            id="keyboard-input"
            value="Click here to use your keyboard."
            autocomplete="off"
          />
          <div class="button-row">
            <button data-letter="q" class="letter letter-input">q</button>
            <button data-letter="w" class="letter letter-input">w</button>
            <button data-letter="e" class="letter letter-input">e</button>
            <button data-letter="r" class="letter letter-input">r</button>
            <button data-letter="t" class="letter letter-input">t</button>
            <button data-letter="y" class="letter letter-input">y</button>
            <button data-letter="u" class="letter letter-input">u</button>
            <button data-letter="i" class="letter letter-input">i</button>
            <button data-letter="o" class="letter letter-input">o</button>
            <button data-letter="p" class="letter letter-input">p</button>
          </div>
          <div class="button-row">
            <button data-letter="a" class="letter letter-input">a</button>
            <button data-letter="s" class="letter letter-input">s</button>
            <button data-letter="d" class="letter letter-input">d</button>
            <button data-letter="f" class="letter letter-input">f</button>
            <button data-letter="g" class="letter letter-input">g</button>
            <button data-letter="h" class="letter letter-input">h</button>
            <button data-letter="j" class="letter letter-input">j</button>
            <button data-letter="k" class="letter letter-input">k</button>
            <button data-letter="l" class="letter letter-input">l</button>
          </div>
          <div class="button-row">
            <button id="letter-Enter" class="letter">Enter</button>
            <button data-letter="z" class="letter letter-input">z</button>
            <button data-letter="x" class="letter letter-input">x</button>
            <button data-letter="c" class="letter letter-input">c</button>
            <button data-letter="v" class="letter letter-input">v</button>
            <button data-letter="b" class="letter letter-input">b</button>
            <button data-letter="n" class="letter letter-input">n</button>
            <button data-letter="m" class="letter letter-input">m</button>
            <button id="letter-Delete" class="letter">
              <svg
                width="20"
                height="21"
                viewBox="0 0 20 21"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M10 8.625L11.875 10.5M11.875 10.5L13.75 12.375M11.875 10.5L13.75 8.625M11.875 10.5L10 12.375M7.85 16.475L2.5375 11.1625C2.36194 10.9867 2.26333 10.7484 2.26333 10.5C2.26333 10.2516 2.36194 10.0133 2.5375 9.8375L7.85 4.525C8.02584 4.34917 8.265 4.25 8.51334 4.25H16.25C16.7473 4.25 17.2242 4.44754 17.5758 4.79917C17.9275 5.15081 18.125 5.62772 18.125 6.125V14.875C18.125 15.3723 17.9275 15.8492 17.5758 16.2008C17.2242 16.5525 16.7473 16.75 16.25 16.75H8.51334C8.265 16.75 8.02584 16.6508 7.85 16.475Z"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
          </div>
        </div>
      </section>
    </main>

    <dialog id="overview-dialog" class="dialog">
      <div class="nav">
        <h1>Overview</h1>
        <button id="overview-close-button" class="light-gray button">
          <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M5 15L15 5M5 5L15 15"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </button>
      </div>
      <div class="two-pane">
        <div class="pane">
          <div class="icon-group">
            <svg
              width="22"
              height="22"
              viewBox="0 0 22 22"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M6.1875 2.75V4.8125M15.8125 2.75V4.8125M2.75 17.1875V6.875C2.75 6.32799 2.9673 5.80339 3.35409 5.41659C3.74089 5.0298 4.26549 4.8125 4.8125 4.8125H17.1875C17.7345 4.8125 18.2591 5.0298 18.6459 5.41659C19.0327 5.80339 19.25 6.32799 19.25 6.875V17.1875M2.75 17.1875C2.75 17.7345 2.9673 18.2591 3.35409 18.6459C3.74089 19.0327 4.26549 19.25 4.8125 19.25H17.1875C17.7345 19.25 18.2591 19.0327 18.6459 18.6459C19.0327 18.2591 19.25 17.7345 19.25 17.1875M2.75 17.1875V10.3125C2.75 9.76549 2.9673 9.24089 3.35409 8.85409C3.74089 8.4673 4.26549 8.25 4.8125 8.25H17.1875C17.7345 8.25 18.2591 8.4673 18.6459 8.85409C19.0327 9.24089 19.25 9.76549 19.25 10.3125V17.1875M11 11.6875H11.0073V11.6948H11V11.6875ZM11 13.75H11.0073V13.7573H11V13.75ZM11 15.8125H11.0073V15.8198H11V15.8125ZM8.9375 13.75H8.94483V13.7573H8.9375V13.75ZM8.9375 15.8125H8.94483V15.8198H8.9375V15.8125ZM6.875 13.75H6.88233V13.7573H6.875V13.75ZM6.875 15.8125H6.88233V15.8198H6.875V15.8125ZM13.0625 11.6875H13.0698V11.6948H13.0625V11.6875ZM13.0625 13.75H13.0698V13.7573H13.0625V13.75ZM13.0625 15.8125H13.0698V15.8198H13.0625V15.8125ZM15.125 11.6875H15.1323V11.6948H15.125V11.6875ZM15.125 13.75H15.1323V13.7573H15.125V13.75Z"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <strong>Daily games</strong>
          </div>
          <div id="overview-daily-games"></div>
        </div>
        <div class="pane">
          <div class="icon-group">
            <svg
              width="23"
              height="22"
              viewBox="0 0 23 22"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M18.375 11C18.375 9.87067 18.3328 8.75142 18.2485 7.64317C18.1836 6.76514 17.8055 5.93963 17.1829 5.31708C16.5604 4.69453 15.7349 4.31637 14.8568 4.25151C12.6221 4.08291 10.3779 4.08291 8.14317 4.25151C7.26513 4.31637 6.43963 4.69453 5.81707 5.31708C5.19452 5.93963 4.81636 6.76514 4.7515 7.64317C4.73592 7.84484 4.72217 8.04742 4.70933 8.25001M18.375 11L21.125 8.25001M18.375 11L15.625 8.25001M4.625 11C4.625 12.1293 4.66717 13.2486 4.7515 14.3568C4.81636 15.2349 5.19452 16.0604 5.81707 16.6829C6.43963 17.3055 7.26513 17.6836 8.14317 17.7485C10.3779 17.9172 12.6221 17.9172 14.8568 17.7485C15.7349 17.6836 16.5604 17.3055 17.1829 16.6829C17.8055 16.0604 18.1836 15.2349 18.2485 14.3568C18.2641 14.1552 18.2778 13.9526 18.2907 13.75M4.625 11L7.375 13.75M4.625 11L1.875 13.75"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <strong>Random games</strong>
          </div>
          <span>Want more than one game a day? Try a random game!</span>
          <div id="overview-random-games-container">
            <button
              id="overview-new-random-game"
              class="small light-gray button"
            >
              <span>New random game</span>
              <svg
                width="15"
                height="15"
                viewBox="0 0 15 15"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M7.5 2.8125V12.1875M12.1875 7.5H2.8125"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
            <div id="overview-random-games"></div>
          </div>
        </div>
      </div>
    </dialog>

    <dialog id="more-dialog" class="dialog">
      <div class="nav">
        <h1>Analysis</h1>
        <button id="more-close-button" class="light-gray button">
          <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M5 15L15 5M5 5L15 15"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </button>
      </div>
      <div class="one-pane">
        <div id="more-pane" class="pane">
          <div class="one-pane-two-pane">
            <div class="pane">
              <div class="icon-group">
                <svg
                  width="22"
                  height="22"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M15.75 6a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0ZM4.501 20.118a7.5 7.5 0 0 1 14.998 0A17.933 17.933 0 0 1 12 21.75c-2.676 0-5.216-.584-7.499-1.632Z"
                    stroke-width="1.5"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
                <strong>Your guesses</strong>
              </div>
            </div>
            <div class="pane">
              <div class="icon-group">
                <svg
                  width="22"
                  height="22"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M9 17.25v1.007a3 3 0 0 1-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0 1 15 18.257V17.25m6-12V15a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 15V5.25m18 0A2.25 2.25 0 0 0 18.75 3H5.25A2.25 2.25 0 0 0 3 5.25m18 0V12a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 12V5.25"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
                <strong>Analysis</strong>
              </div>
            </div>
          </div>
          <div id="more-no-analysis" class="one-pane-two-pane">
            <div id="more-no-analysis-guesses" class="pane"></div>
            <div class="pane">
              <button id="more-run" class="small light-gray button">
                <span>Run analysis</span>
                <svg
                  width="15"
                  height="15"
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  fill="none"
                >
                  <path
                    d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347a1.125 1.125 0 0 1 0 1.972l-11.54 6.347a1.125 1.125 0 0 1-1.667-.986V5.653Z"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
            </div>
          </div>
          <div id="more-panel" class="one-pane-two-pane centered">
            <span>Skill score: <strong id="more-score"></strong>/100</span>
            <label id="more-strict" class="checkbox">
              <input id="more-strict-checkbox" type="checkbox" />
              <span>Strict mode</span>
            </label>
          </div>
          <div id="more-analysis" class="pane"></div>
        </div>
      </div>
    </dialog>
  </body>
  <script id="variables">
    const Constants = {
      Api: {
        Dict: "/dict.txt",
      },
      WordLength: 5,
      Attempts: 6,
      KeyboardInputPrompt: "Click here to use your keyboard.",
      Colors: ["green", "yellow", "gray"],
      BotTopChoices: 10,
    };

    const AppState = {
      now: undefined,
      currentGameKey: undefined,
    };

    let GameDict = undefined;
    let GameHistory = {};
    let GameState = {};

    const Bindings = {
      Control: {
        OverviewButton: {
          Element: document.getElementById("overview-button"),
          Listener: undefined,
        },
        OverviewCloseButton: {
          Element: document.getElementById("overview-close-button"),
          Listener: undefined,
        },
        OverviewNewRandomGame: {
          Element: document.getElementById("overview-new-random-game"),
          Listener: undefined,
        },
        MoreButton: {
          Element: document.getElementById("more-button"),
          Listener: undefined,
        },
        MoreCloseButton: {
          Element: document.getElementById("more-close-button"),
          Listener: undefined,
        },
        MoreAnalysis: {
          Element: document.getElementById("more-run"),
          Listener: undefined,
        },
        MoreStrictModeCheckbox: {
          Element: document.getElementById("more-strict-checkbox"),
          Listener: undefined,
        },
      },
      Dialogs: {
        OverviewDialog: document.getElementById("overview-dialog"),
        OverviewDailyGames: document.getElementById("overview-daily-games"),
        OverviewRandomGames: document.getElementById("overview-random-games"),
        ArchiveDialog: document.getElementById("archive-dialog"),
        MoreDialog: document.getElementById("more-dialog"),
      },
      Word: {
        Container: document.getElementById("input"),
        Attempt1: document.getElementById("attempt-1"),
        Attempt2: document.getElementById("attempt-2"),
        Attempt3: document.getElementById("attempt-3"),
        Attempt4: document.getElementById("attempt-4"),
        Attempt5: document.getElementById("attempt-5"),
        Attempt6: document.getElementById("attempt-6"),
        ArchiveWord: document.getElementById("archive-word"),
      },
      Analysis: {
        NoAnalysis: document.getElementById("more-no-analysis"),
        NoAnalysisGuesses: document.getElementById("more-no-analysis-guesses"),
        Analysis: document.getElementById("more-analysis"),
        Panel: document.getElementById("more-panel"),
        Score: document.getElementById("more-score"),
        StrictMode: document.getElementById("more-strict"),
      },
      Interactive: {
        InputKeyup: {
          Element: document.getElementById("keyboard-input"),
          Listener: undefined,
        },
        InputInput: {
          Element: document.getElementById("keyboard-input"),
          Listener: undefined,
        },
        Enter: {
          Element: document.getElementById("letter-Enter"),
          Listener: undefined,
        },
        Delete: {
          Element: document.getElementById("letter-Delete"),
          Listener: undefined,
        },
        Letters: Array.from(document.querySelectorAll(".letter-input")).map(
          (Element) => ({
            Element,
            Listener: undefined,
          })
        ),
      },
      Document: {
        Element: document,
        Listener: undefined,
      },
    };
  </script>
  <script id="gamegen">
    const loadDict = async (length) => {
      if (GameDict && GameDict.has(length)) return GameDict.get(length);

      if (!GameDict) {
        GameDict = new Map();

        const response = await fetch(Constants.Api.Dict);
        const dict = await response.text();
        const allWords = dict.split("\n").map((word) => word.trim());

        GameDict.set(0, allWords);
      }

      const lengthWords = GameDict.get(0).filter(
        (word) => word.length === length
      );
      GameDict.set(length, lengthWords);
      return lengthWords;
    };

    // deterministically generates a valid game given a seed and length
    const generateGame = async (seed, length = Constants.WordLength) => {
      if (length < 4 || Number.isNaN(length))
        throw new Error("Invalid length!");

      performance.mark("generate-start");

      // only loads dictionary if it doesn't exist
      const dict = await loadDict(length);

      const encoder = new TextEncoder();
      const data = encoder.encode(seed);
      const digest = await crypto.subtle.digest("SHA-1", data);

      const view = new DataView(digest);
      const index =
        (view.getUint8(0) +
          view.getUint8(1) *
            view.getUint8(2) *
            view.getUint8(3) *
            view.getUint8(4)) %
        dict.length;

      performance.mark("generate-end");
      const measure = performance.measure(
        "generate-measure",
        "generate-start",
        "generate-end"
      );
      console.log(
        `Took ${measure.duration.toFixed(2)}ms to generate latest game.`
      );

      return dict[index];
    };
  </script>
  <script id="gameplay">
    const getWordLetterState = (word, attempt, position) => {
      if (word.length !== attempt.length)
        throw new Error(
          `Cannot get state of attempt since length is different: wanted ${word.length}, got ${attempt.length}`
        );

      const letter = attempt.charAt(position);

      if (word.charAt(position) === letter) {
        /**
         * Always return green if the letter is right
         */
        return 0;
      } else {
        /**
         * We need to be more careful if it's not an
         * exact match. Specifically, we need to
         * highlight the correct number of letters.
         */
        let lettersInWord = 0;
        let greenLetters = 0;
        let lettersToLeftInAttempt = 0;

        for (let i = 0; i < word.length; i++) {
          const wordHasLetter = word.charAt(i) === letter;
          const attemptHasLetter = attempt.charAt(i) === letter;

          if (wordHasLetter) lettersInWord++;
          if (wordHasLetter && attemptHasLetter) greenLetters++;
          if (i < position && attemptHasLetter) lettersToLeftInAttempt++;
        }

        /**
         * We only return yellow if these are true:
         * a) there's at least one of this letter in the word
         * b) there are fewer of these green letters than there are these letters in the word
         * c) there are fewer of these letters to the left of this one
         * than the difference between these green letters and letters in the word
         */
        return lettersInWord - greenLetters - lettersToLeftInAttempt > 0
          ? 1
          : 2;
      }
    };

    const getLetterState = (word, letter, attempts) => {
      let finalState = "";

      for (const attempt of attempts) {
        if (attempt.includes(letter)) {
          for (let i = 0; i < attempt.length; i++) {
            const attemptLetter = attempt.charAt(i);

            if (attemptLetter === letter) {
              const state = getWordLetterState(word, attempt, i);

              if (state === 0) return "green";
              if (state === 1) finalState = "yellow";
              if (state === 2 && finalState === "") finalState = "gray";
            }
          }
        }
      }

      return finalState;
    };

    const archiveGame = (gameKey) => {
      if (!(gameKey in GameHistory))
        throw new Error("Attempted to archive nonexistent game!");

      if (gameKey === AppState.now)
        throw new Error("Attempted to archive current game!");

      GameHistory[gameKey].archived = true;

      updateDisplayState();
    };

    const switchGame = async (gameKey) => {
      if (!(gameKey in GameHistory))
        throw new Error("Attempted to switch to nonexistent game!");
      AppState.currentGameKey = gameKey;
      GameState = GameHistory[AppState.currentGameKey];
      await loadDict(GameState.length);
      updateDisplayState();
    };

    const loadRandom = async (length) => {
      const uuid = crypto.randomUUID();

      const word = await generateGame(uuid, length);

      const key = `${length ?? Constants.WordLength}+${uuid.slice(0, 6)}`;

      GameHistory[key] = {
        date: key,
        word,
        length: word.length,
        activeAttempt: 0,
        attempts: [],
      };

      await switchGame(key);
    };

    const load = async () => {
      AppState.now = new Date(
        Date.now() - 3 * 60 * 60 * 1000
      ).toLocaleDateString("en-CA");
      const localDataString = window.localStorage.getItem("word_History");

      if (localDataString) {
        GameHistory = JSON.parse(localDataString);
      }

      if (!GameHistory[AppState.now]) {
        const word = await generateGame(AppState.now);

        GameHistory[AppState.now] = {
          date: AppState.now,
          word,
          length: word.length,
          activeAttempt: 0,
          attempts: [],
        };
      }

      await switchGame(AppState.now);
    };

    const save = async () => {
      window.localStorage.setItem("word_History", JSON.stringify(GameHistory));
    };

    const updateDisplayState = () => {
      Bindings.Word.ArchiveWord.innerHTML = GameState.word;

      Bindings.Dialogs.ArchiveDialog.close();
      if (GameState.archived && !GameState.attempts.includes(GameState.word)) {
        Bindings.Dialogs.ArchiveDialog.show();
      }

      for (let i = 0; i < Constants.Attempts; i++) {
        const attempt = GameState.attempts[i];

        if (i < GameState.activeAttempt) {
          if (attempt?.length !== GameState.length)
            throw new Error("Game has misconfigured attempts!");

          Bindings.Word[`Attempt${i + 1}`].innerHTML = attempt
            .split("")
            .map(
              (letter, position) =>
                `<div class="attempt-letter ${
                  Constants.Colors[
                    getWordLetterState(GameState.word, attempt, position)
                  ]
                }">${letter}</div>`
            )
            .join("");
        } else if (i === GameState.activeAttempt) {
          let innerHTML = "";

          for (let j = 0; j < GameState.length; j++) {
            innerHTML += `<div class="attempt-letter">${
              attempt?.charAt(j) ?? ""
            }</div>`;
          }

          Bindings.Word[`Attempt${i + 1}`].innerHTML = innerHTML;
        } else {
          Bindings.Word[`Attempt${i + 1}`].innerHTML = new Array(
            GameState.length
          )
            .fill(0)
            .map(() => '<div class="attempt-letter"></div>')
            .join("");
        }
      }

      Bindings.Dialogs.OverviewDailyGames.innerHTML = Object.entries(
        GameHistory
      )
        .sort()
        .reverse()
        .reduce(
          (innerHTML, [key, game]) =>
            key === AppState.now || key.includes("+")
              ? innerHTML
              : (innerHTML += `<button data-game-key=${key} class="small ${
                  AppState.currentGameKey === key ? "blue" : "light-gray"
                } button">
                    <span>
                      <strong>
                        ${key.slice(5, 7)}/${key.slice(8, 10)}
                      </strong>
                    </span>
                    ${
                      game.archived
                        ? `<svg width="15" height="16" viewBox="0 0 15 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12.6562 4.85416L12.2656 11.4992C12.2446 11.8573 12.0874 12.1939 11.8264 12.44C11.5653 12.6861 11.22 12.823 10.8613 12.8229H4.13875C3.77998 12.823 3.43472 12.6861 3.17364 12.44C2.91257 12.1939 2.75542 11.8573 2.73438 11.4992L2.34375 4.85416M6.25 7.19791H8.75M2.10938 4.85416H12.8906C13.2787 4.85416 13.5938 4.53916 13.5938 4.15103V3.21353C13.5938 2.82541 13.2787 2.51041 12.8906 2.51041H2.10938C1.72125 2.51041 1.40625 2.82541 1.40625 3.21353V4.15103C1.40625 4.53916 1.72125 4.85416 2.10938 4.85416Z"  stroke-linecap="round" stroke-linejoin="round"/>
                          </svg>`
                        : ""
                    }
                  </button>`),
          `<button data-game-key=${AppState.now} class="small ${
            AppState.currentGameKey === AppState.now ? "blue" : "light-gray"
          } button">
            <span>
              <strong>Today</strong>
            </span>
            ${
              GameHistory[AppState.now].archived
                ? `<svg width="15" height="16" viewBox="0 0 15 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12.6562 4.85416L12.2656 11.4992C12.2446 11.8573 12.0874 12.1939 11.8264 12.44C11.5653 12.6861 11.22 12.823 10.8613 12.8229H4.13875C3.77998 12.823 3.43472 12.6861 3.17364 12.44C2.91257 12.1939 2.75542 11.8573 2.73438 11.4992L2.34375 4.85416M6.25 7.19791H8.75M2.10938 4.85416H12.8906C13.2787 4.85416 13.5938 4.53916 13.5938 4.15103V3.21353C13.5938 2.82541 13.2787 2.51041 12.8906 2.51041H2.10938C1.72125 2.51041 1.40625 2.82541 1.40625 3.21353V4.15103C1.40625 4.53916 1.72125 4.85416 2.10938 4.85416Z"  stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>`
                : ""
            }
          </button>`
        );
      Bindings.Dialogs.OverviewRandomGames.innerHTML = Object.entries(
        GameHistory
      )
        .sort()
        .reduce(
          (innerHTML, [key, game]) =>
            !key.includes("+")
              ? innerHTML
              : (innerHTML += `<button data-game-key=${key} class="small ${
                  key === AppState.currentGameKey ? "blue" : "light-gray"
                } button">
                  <span>
                    <strong>
                      ${key.replace("+", " • ")}
                    </strong>
                  </span>
                  ${
                    game.archived
                      ? `<svg width="15" height="16" viewBox="0 0 15 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                          <path d="M12.6562 4.85416L12.2656 11.4992C12.2446 11.8573 12.0874 12.1939 11.8264 12.44C11.5653 12.6861 11.22 12.823 10.8613 12.8229H4.13875C3.77998 12.823 3.43472 12.6861 3.17364 12.44C2.91257 12.1939 2.75542 11.8573 2.73438 11.4992L2.34375 4.85416M6.25 7.19791H8.75M2.10938 4.85416H12.8906C13.2787 4.85416 13.5938 4.53916 13.5938 4.15103V3.21353C13.5938 2.82541 13.2787 2.51041 12.8906 2.51041H2.10938C1.72125 2.51041 1.40625 2.82541 1.40625 3.21353V4.15103C1.40625 4.53916 1.72125 4.85416 2.10938 4.85416Z"  stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>`
                      : ""
                  }
                </button>`),
          ""
        );

      updateButtonBindings();

      try {
        updateAnalysis(
          !!Bindings.Control.MoreStrictModeCheckbox.Element.checked
        );
      } catch (err) {
        console.log(`Error rendering analysis, maybe it's out of date?`);
        delete GameState.analysis;
        delete GameState.strictAnalysis;
        updateDisplayState();
      }

      save();
    };

    const updateLetter = (attempt, char, letter) => {
      const attemptRow = Bindings.Word[`Attempt${attempt + 1}`];
      const attemptLetter = attemptRow.querySelector(
        `.attempt-letter:nth-child(${char + 1})`
      );

      if (!attemptLetter)
        throw new Error(
          `Attempt ${attempt} char ${char} not found when trying to update to ${letter}`
        );

      if (letter) {
        attemptLetter.innerHTML = letter;
        attemptLetter.classList.add("pulse");
      } else {
        attemptLetter.innerHTML = "";
        attemptLetter.classList.remove("pulse");
      }

      /**
       * Handle horizontal scrolling
       */
      const attemptLength = GameState.attempts[attempt]?.length ?? 0;

      const containerPaddingLeft =
        parseFloat(getComputedStyle(Bindings.Word.Container).paddingLeft) || 0;
      const containerPaddingRight =
        parseFloat(getComputedStyle(Bindings.Word.Container).paddingRight) || 0;
      const containerColumnGap =
        parseFloat(getComputedStyle(Bindings.Word.Container).columnGap) || 0;
      const letterWidth =
        parseFloat(
          getComputedStyle(document.querySelector(".attempt-letter")).width
        ) || 0;
      const windowWidth = window.innerWidth;

      /**
       * The cursor (or last non-empty square) must be at least
       * one padding's length away from the left edge.
       */
      const maxScrollLeft =
        (attemptLength - 1) * (letterWidth + containerColumnGap);

      /**
       * The cursor must be at most one padding's length away
       * from the right edge.
       */
      const lengthToCursor =
        containerPaddingLeft +
        (attemptLength - 1) * (letterWidth + containerColumnGap);
      const overflow = lengthToCursor - windowWidth;
      const minScrollLeft = overflow + letterWidth + containerPaddingRight;

      const currentScrollLeft = Bindings.Word.Container.scrollLeft;
      Bindings.Word.Container.scrollLeft = Math.max(
        Math.min(currentScrollLeft, maxScrollLeft),
        minScrollLeft
      );
      Bindings.Word.Container.scrollIntoView();

      save();
    };

    const updateAttempt = async (word, attempt, letters) => {
      const attemptRow = Bindings.Word[`Attempt${attempt}`];
      const attemptLetters = attemptRow.querySelectorAll(".attempt-letter");

      for (let i = 0; i < attemptLetters.length; i++) {
        const attemptLetter = attemptLetters[i];

        const shrinkAnimation = attemptLetter.animate(
          [
            { transform: "perspective(12rem) rotate3d(0, 1, 0, 0deg)" },
            { transform: "perspective(12rem) rotate3d(0, 1, 0, 90deg)" },
          ],
          { duration: 150, easing: "ease-out", fill: "forwards" }
        );
        await shrinkAnimation.finished;
        attemptLetters[i].classList.add(
          "submitted",
          Constants.Colors[getWordLetterState(word, letters, i)]
        );
        const growAnimation = attemptLetter.animate(
          [
            { transform: "perspective(12rem) rotate3d(0, 1, 0, 270deg)" },
            { transform: "perspective(12rem) rotate3d(0, 1, 0, 360deg)" },
          ],
          { duration: 200, easing: "ease-out", fill: "forwards" }
        );
        if (i === attemptLetters.length - 1) {
          await growAnimation.finished;
        }
      }

      if (GameState.attempts[attempt - 1] === word) {
        for (let i = 0; i < attemptLetters.length; i++) {
          const attemptLetter = attemptLetters[i];

          const jumpAnimation = attemptLetter.animate(
            [
              { transform: "translateY(0)" },
              { transform: "translateY(-1rem)" },
            ],
            { duration: 125, easing: "ease-out", fill: "forwards" }
          );
          await jumpAnimation.finished;
          const fallAnimation = attemptLetter.animate(
            [
              { transform: "translateY(-1rem)" },
              { transform: "translateY(0rem)" },
            ],
            { duration: 75, easing: "ease-out", fill: "forwards" }
          );
          if (i === attemptLetters.length - 1) {
            await fallAnimation.finished;
          }
        }
      }

      save();
    };

    const clearBinding = (binding, event = "pointerdown") => {
      binding.Element.removeEventListener("pointerdown", binding.Listener);
    };

    const updateBinding = (binding, callback, event = "pointerdown") => {
      binding.Element.removeEventListener(event, binding.Listener);
      binding.Listener = callback;
      binding.Element.addEventListener(event, binding.Listener);
    };

    const updateButtonBindings = () => {
      if (GameState.archived) {
        Bindings.Control.MoreButton.Element.removeAttribute("disabled");

        clearBinding(Bindings.Document, "keydown");

        Bindings.Interactive.InputInput.Element.setAttribute("disabled", true);
        clearBinding(Bindings.Interactive.InputKeyup, "keyup");
        clearBinding(Bindings.Interactive.InputInput, "input");

        Bindings.Interactive.Enter.Element.setAttribute("disabled", true);
        clearBinding(Bindings.Interactive.Enter);

        Bindings.Interactive.Delete.Element.setAttribute("disabled", true);
        clearBinding(Bindings.Interactive.Delete);

        Bindings.Interactive.Letters.forEach((Binding) => {
          Binding.Element.classList.remove("green");
          Binding.Element.classList.remove("yellow");
          Binding.Element.classList.remove("gray");

          if (GameState.word.includes(Binding.Element.dataset.letter))
            Binding.Element.classList.add("green");
          Binding.Element.setAttribute("disabled", true);
          clearBinding(Binding);
        });
      } else {
        Bindings.Control.MoreButton.Element.setAttribute("disabled", true);
        Bindings.Interactive.InputInput.Element.removeAttribute("disabled");
        Bindings.Interactive.Enter.Element.removeAttribute("disabled");
        Bindings.Interactive.Delete.Element.removeAttribute("disabled");

        const onEnter = async () => {
          const attempt = GameState.attempts[GameState.activeAttempt];

          if (
            attempt &&
            attempt.length === GameState.length &&
            GameDict.get(GameState.length)?.includes(attempt)
          ) {
            GameState.activeAttempt = GameState.activeAttempt + 1;

            if (
              GameState.activeAttempt >= Constants.Attempts ||
              GameState.attempts.includes(GameState.word)
            ) {
              GameState.archived = true;
              await updateAttempt(
                GameState.word,
                GameState.activeAttempt,
                attempt
              );
              updateDisplayState();
            } else {
              updateAttempt(GameState.word, GameState.activeAttempt, attempt);
              updateButtonBindings();
            }
          } else {
            Bindings.Word[`Attempt${GameState.activeAttempt + 1}`].animate(
              new Array(9).fill(0).map((_, index) => ({
                transform: `translate(${~~(index / 2) % 2 === 0 ? "" : "-"}${
                  index % 2 === 0 ? "0" : "0.25"
                }rem)`,
              })),
              { duration: 360, easing: "linear", fill: "forwards" }
            );

            updateDisplayState();
          }
        };
        updateBinding(Bindings.Interactive.Enter, onEnter);

        const onDelete = () => {
          const attempt = GameState.attempts[GameState.activeAttempt];

          if (attempt && attempt.length > 0) {
            GameState.attempts[GameState.activeAttempt] = attempt.slice(
              0,
              attempt.length - 1
            );

            updateLetter(GameState.activeAttempt, attempt.length - 1);
          }
        };
        updateBinding(Bindings.Interactive.Delete, onDelete);

        const onLetter = (letter) => {
          const attempt = GameState.attempts[GameState.activeAttempt];

          if (!attempt || attempt.length < GameState.length) {
            GameState.attempts[GameState.activeAttempt] =
              (attempt ?? "") + letter;

            updateLetter(GameState.activeAttempt, attempt?.length ?? 0, letter);
          }
        };
        for (const Binding of Bindings.Interactive.Letters) {
          Binding.Element.classList.remove("green");
          Binding.Element.classList.remove("yellow");
          Binding.Element.classList.remove("gray");
          Binding.Element.removeAttribute("disabled");

          const letterState = getLetterState(
            GameState.word,
            Binding.Element.dataset.letter,
            GameState.attempts.slice(0, GameState.activeAttempt)
          );
          if (letterState) Binding.Element.classList.add(letterState);

          updateBinding(Binding, () =>
            onLetter(Binding.Element.dataset.letter)
          );
        }

        updateBinding(
          Bindings.Interactive.InputInput,
          (e) => {
            Bindings.Interactive.InputInput.Element.value =
              Constants.KeyboardInputPrompt;

            if (e.inputType === "deleteContentBackward") return onDelete();

            for (const { Element } of Bindings.Interactive.Letters) {
              if (
                e.data?.toLowerCase() === Element.dataset.letter &&
                !(e.altKey || e.ctrlKey || e.metaKey || e.shiftKey)
              ) {
                onLetter(Element.dataset.letter);
              }
            }
          },
          "input"
        );

        updateBinding(
          Bindings.Interactive.InputKeyup,
          (e) => {
            if (e.key === "Enter") return onEnter();
          },
          "keyup"
        );

        updateBinding(
          Bindings.Document,
          (e) => {
            if (Bindings.Interactive.InputInput.Element.contains(e.target))
              return;

            if (e.key === "Enter") onEnter();
            if (e.key === "Backspace") onDelete();

            for (const { Element } of Bindings.Interactive.Letters) {
              if (
                e.key.toLowerCase() === Element.dataset.letter &&
                !(e.altKey || e.ctrlKey || e.metaKey || e.shiftKey)
              ) {
                onLetter(Element.dataset.letter);
              }
            }
          },
          "keydown"
        );
      }

      Bindings.Dialogs.OverviewDialog.querySelectorAll(
        "button[data-game-key]"
      ).forEach((button) =>
        button.addEventListener("click", () => {
          const key = button.dataset.gameKey;

          if (
            AppState.currentGameKey === key &&
            AppState.currentGameKey !== AppState.now &&
            confirm(`Delete game ${key.replace("+", " • ")}?`)
          ) {
            delete GameHistory[key];
            switchGame(AppState.now);
          } else {
            switchGame(key);
            Bindings.Dialogs.OverviewDialog.close();
            Bindings.Control.OverviewButton.Element.blur();
          }
        })
      );
    };

    const updateControlButtonsOnce = () => {
      updateBinding(
        Bindings.Control.OverviewButton,
        () => {
          Bindings.Dialogs.OverviewDialog.showModal();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewCloseButton,
        () => {
          Bindings.Dialogs.OverviewDialog.close();
          Bindings.Control.OverviewButton.Element.blur();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewNewRandomGame,
        async () => {
          const lengthString = prompt(
            "How long should the word be? Choose any number greater than 4.",
            "5"
          );

          if (
            !lengthString ||
            Number.isNaN(parseInt(lengthString)) ||
            parseInt(lengthString) < 4
          ) {
            alert("That isn't a valid length!");
          } else {
            const length = parseInt(lengthString);

            await loadRandom(length);
            Bindings.Dialogs.OverviewDialog.close();
            Bindings.Control.OverviewButton.Element.blur();
          }
        },
        "click"
      );
      updateBinding(
        Bindings.Control.MoreButton,
        () => {
          Bindings.Dialogs.MoreDialog.showModal();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.MoreCloseButton,
        () => {
          Bindings.Dialogs.MoreDialog.close();
          Bindings.Control.MoreButton.Element.blur();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.MoreAnalysis,
        async () => {
          analyze();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.MoreStrictModeCheckbox,
        async () => {
          updateDisplayState();
        },
        "change"
      );
    };

    const updateAnalysis = (strictMode = false) => {
      const key =
        strictMode && GameState.strictAnalysis ? "strictAnalysis" : "analysis";

      if (GameState[key]) {
        if (GameState.strictAnalysis)
          Bindings.Analysis.StrictMode.classList.remove("hidden");
        else Bindings.Analysis.StrictMode.classList.add("hidden");
        Bindings.Analysis.Panel.classList.remove("hidden");
        Bindings.Analysis.NoAnalysis.classList.add("hidden");

        Bindings.Analysis.Score.innerHTML = Math.floor(
          GameState[key].reduce(
            (score, analysis, index) =>
              index === 0
                ? score
                : score +
                  convertHeuristicToScore(
                    analysis.attempt.heuristic,
                    analysis.bestHeuristic,
                    analysis.worstHeuristic
                  ),
            0
          ) /
            (GameState[key].length - 1)
        );

        Bindings.Analysis.NoAnalysisGuesses.innerHTML = "";
        Bindings.Analysis.Analysis.innerHTML = GameState[key].reduce(
          (innerHTML, analysis, index) =>
            (innerHTML += `<span class="divider"></span>
            <div class="one-pane-two-pane">
              <div class="pane">
                <strong>Guess ${index + 1}</strong>
                ${convertChoiceToDetails(analysis, analysis.attempt, true)}
              </div>
              <div class="pane">
                <strong>Top choices</strong>
                ${
                  index === 0
                    ? "We don't calculate the top choices for the first guess, and it isn't included in your score. We also only show one dictionary partition – the one containing this challenge's word."
                    : analysis.choices.reduce(
                        (innerHTML, choice) =>
                          (innerHTML += convertChoiceToDetails(
                            analysis,
                            choice,
                            false
                          )),
                        ""
                      )
                }
              </div>
            </div>`),
          ""
        );
      } else {
        Bindings.Analysis.Panel.classList.add("hidden");
        Bindings.Analysis.NoAnalysis.classList.remove("hidden");

        Bindings.Analysis.Analysis.innerHTML = "";
        Bindings.Analysis.NoAnalysisGuesses.innerHTML =
          GameState.attempts.reduce(
            (innerHTML, attempt) =>
              (innerHTML += `<div class="strong blue card">${attempt}</div>`),
            ""
          );
      }
    };

    const convertChoiceToDetails = (analysis, choice, isAttempt = false) => `
    <details class="analysis-choice lightest-gray ${
      isAttempt ? "sticky" : ""
    } card" ${isAttempt ? "open" : ""}>
      <summary>
        <div class="${isAttempt ? "blue" : "light-gray"} info card">
          <span class="strong">${choice.word}</span>
          <span class="strong">${convertHeuristicToScore(
            choice.heuristic,
            analysis.bestHeuristic,
            analysis.worstHeuristic
          )}</span>
          <span class="divider"></span><span class="hidden"></span>
          <span>Partitions</span>
          <span>${choice.size}</span>
          <span>Expected words left</span>
          <span>${choice.expectedGroupLength.toFixed(1)}</span>
          <span>Actual words left</span>
          <span>${choice.actualGroupLength}</span>
          <span>Chance guess is right</span>
          <span>${(100 * choice.guessProbability).toFixed(0)}%</span>
        </div>
      </summary>
      <div class="pane">
        ${Object.entries(choice.groups)
          .sort((a, b) => b[1].length - a[1].length)
          .reduce(
            (innerHTML, [code, words]) =>
              (innerHTML += `
                <details class="${
                  choice.code === code ? "light-green" : "light-gray"
                } card">
                  <summary><span class="words"><span class="dotlist">${code
                    .split("")
                    .reduce(
                      (innerHTML, letter, index) =>
                        (innerHTML += `<span class="${
                          Constants.Colors[parseInt(letter) || 0]
                        } dot">${choice.word.charAt(index)}</span>`),
                      ""
                    )}</span><strong class="right">${
                words.length
              }</strong></span></summary>
                  <div class="wordlist">
                    ${words.join(", ")}
                  </div>
                </details>
              `),
            ""
          )}  
      </div>
    </details>`;
  </script>
  <script id="bot">
    const convertHeuristicToScore = (
      heuristic,
      bestHeuristic,
      worstHeuristic
    ) => {
      if (
        heuristic === 0 ||
        worstHeuristic === 0 ||
        worstHeuristic - bestHeuristic === 0
      )
        return 100;
      const delta =
        (heuristic - bestHeuristic) / (worstHeuristic - bestHeuristic);
      const curvedDelta = Math.sqrt(delta);
      return Math.floor(100 * (1 - curvedDelta));
    };

    const codeAttempt = (word, attempt) => {
      let code = "";
      for (let i = 0; i < attempt.length; i++) {
        code += getWordLetterState(word, attempt, i);
      }
      return code;
    };

    const filterDictByAttemptAndCode = (dict, attempt, code) => {
      if (attempt.length !== code.length)
        throw new Error("Attempt and code must have same length!");

      return dict.filter((word) => code === codeAttempt(word, attempt));
    };

    const partitionDictIntoGroupsByAttempt = (dict, attempt) => {
      const groups = new Map();

      dict.forEach((word) => {
        const code = codeAttempt(word, attempt);
        if (groups.has(code)) {
          groups.get(code).push(word);
        } else {
          groups.set(code, [word]);
        }
      });

      return groups;
    };

    const analyzeAttempt = (choiceDict, wordDict, attempt, targetWord) => {
      let worstHeuristic = 0;
      let bestHeuristic = Number.MAX_SAFE_INTEGER;

      const choiceRankings = choiceDict.map((word) => {
        const code = codeAttempt(targetWord, word);
        const groups = partitionDictIntoGroupsByAttempt(wordDict, word);
        const inWordDict = wordDict.includes(word);
        const heuristic =
          (wordDict.length - (inWordDict ? 1 : 0)) / (groups.size || 1);

        if (heuristic < bestHeuristic) bestHeuristic = heuristic;
        if (heuristic > worstHeuristic) worstHeuristic = heuristic;

        return {
          word,
          code,
          groups: Object.fromEntries(groups),
          size: groups.size,
          expectedGroupLength: wordDict.length / (groups.size || 1),
          actualGroupLength: groups.get(code)?.length ?? 0,
          inWordDict,
          heuristic,
          guessProbability: inWordDict ? 1 / wordDict.length : 0,
          isAttempt: word === attempt,
        };
      });

      const choiceAttempt = choiceRankings.find(
        (choice) => choice.word === attempt
      );
      const choices = choiceRankings
        .filter((choice) => bestHeuristic >= 1 || choice.heuristic < 1)
        .sort((a, b) => a.heuristic - b.heuristic)
        .slice(0, Constants.BotTopChoices);

      return {
        attempt: choiceAttempt,
        choices,
        bestHeuristic,
        worstHeuristic,
      };
    };

    const analyzeGame = async (strictMode = false) => {
      const key = strictMode ? "strictAnalysis" : "analysis";
      const dict = await loadDict(GameState.length);

      GameState[key] = [];

      let guessesAreStrictMode = true;
      let carriedDict = dict;
      for (
        let i = 0;
        i < Math.min(Constants.Attempts, GameState.attempts.length);
        i++
      ) {
        const attempt = GameState.attempts[i];
        const code = codeAttempt(GameState.word, attempt);
        const wordDict = strictMode ? carriedDict : dict;

        guessesAreStrictMode &&= carriedDict.includes(attempt);

        if (i === 0) {
          const attemptGroups = partitionDictIntoGroupsByAttempt(
            wordDict,
            attempt
          );
          const attemptHeuristic = wordDict.length / (attemptGroups.size || 1);

          GameState[key][i] = {
            attempt: {
              word: attempt,
              code,
              groups: {
                [code]: attemptGroups.get(code),
              },
              size: attemptGroups.size,
              expectedGroupLength: attemptHeuristic,
              actualGroupLength:
                attemptGroups.get(codeAttempt(GameState.word, attempt))
                  ?.length ?? 0,
              inWordDict: true,
              heuristic: attemptHeuristic,
              guessProbability: 1 / wordDict.length,
            },
            choices: [],
            bestHeuristic: attemptHeuristic,
            worstHeuristic: attemptHeuristic,
          };
        } else {
          GameState[key][i] = analyzeAttempt(
            wordDict,
            carriedDict,
            attempt,
            GameState.word
          );
        }

        carriedDict = filterDictByAttemptAndCode(
          carriedDict,
          GameState.attempts[i],
          codeAttempt(GameState.word, attempt)
        );
      }

      return guessesAreStrictMode;
    };

    const analyze = async () => {
      if (!GameState.archived)
        throw new Error("Cannot analyze incomplete game!");

      performance.mark("analysis-start");

      const guessesAreStrictMode = await analyzeGame(false);

      if (guessesAreStrictMode) {
        await analyzeGame(true);
      }

      updateDisplayState();

      performance.mark("analysis-end");
      const measure = performance.measure(
        "analysis-measure",
        "analysis-start",
        "analysis-end"
      );
      console.log(
        `Took ${measure.duration.toFixed(2)}ms to analyze game ${
          GameState.date
        }.`
      );
    };
  </script>
  <script id="run">
    const play = async () => {
      if (
        !window.crypto ||
        !window.crypto.subtle ||
        !window.DataView ||
        !window.TextEncoder
      )
        throw new Error("A required API is missing.");

      await load();

      updateControlButtonsOnce();

      Object.entries(GameHistory).forEach(([key, game]) => {
        if (key !== AppState.now && !key.includes("+")) {
          archiveGame(key);
        }
      });

      if ("serviceWorker" in navigator) {
        await navigator.serviceWorker.register("./sw.js", {
          scope: "/",
        });
      }
    };

    play();
  </script>
</html>
